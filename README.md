# nanocubesBenchmark
A benchmark for the new multithreaded nanocube C++ implementation

Will run p numbers of tests, where p is the maximal number of nanocube parts to be reached during the benchmark. (See –p argument)
Each test run of will build a nanocube and run the queries listed in a text file. (See -u argument)
The test results are written to stdout and additionally logged into testlog.txt next to the benchmark executable.

# Arguments

-u text file path to a file holding lines of nanocube queries e.g. count.r("timestamp",mt_interval_sequence(0,524289,8192)).
   Alternatively a .harp or .har file, a HTTP tracing file generated by the Firefox Add-on FireBug with NetExport Plugin.

-p Number of nanocube parts. Benchmark will start with 1 part and the last run will have "p" parts.
   Use auto keyword in front of the number (e.g. auto4) to benchmark with automatically generated quad tree splitting functions. (recommended)
   
-d file path to .dmp file, holding the records to be inserted. See nanocube-binning-csv python script to generate one from a csv file.

-n file path to nanocube executable. Optional if nanocube executable is located in the same folder as the benchmark executable.

-m maximal number of records to be inserted

-f report frequency in seconds

-q query port. Default is 29512.

-t Number of threads for querying (mongoose). Default is 100.

-x Number of randomly selected records to automatically generate the quad tree partition functions. (See –p argument)

-g (Windows only) Size of the temporary memory mapping file in gigabytes. Default is 32GB.

-w (Windows only) folder path for the temporary memory files. Default is windows temp folder.

example:

-u PeterTestData.harp -p auto6 -d NanoCubePeterTestData.dmp -m 100000 -f 1

Will use queries from PeterTestData.harp, build cubes with up to 6 parts and auto generate partition functions.
Reads in 100000 records/points from NanoCubePeterTestData.dmp and report the status every second.
